#### Basics
- Threads in python can be created:
  - Without using any class
  - By extending Thread class
  - Without extending Thread class
- Every thread in python has name. It may be default name generated by Python or customized name provided by programmer.
- Every Thread has implicit variable "name" to represent name of Thread.
- We can get and set name of thread by using the following Thread class methods.
    - t.getName() -> Returns name of thread
    - t.setName(newName) -> sets name of thread

-  For every thread internally a unique identification number is available. We can access this
 id by using implicit variable "ident".
   - current_thread().ident
- enumerate() - This function returns a list of all active threads currently running.
- isAlive() method checks whether a thread is still executing or not.
- If a thread wants to wait till another thread completes execution, use join()
- Threads which are running in the background are called Daemon Threads.
- The main objective of Daemon Threads is to provide support for Non Daemon Threads (like main thread) Eg: Garbage Collector

#### Synchronization
- Lock
  - Locks are the most fundamental synchronization mechanism provided by threading module.
  - We can create Lock object as follows:
    - l = Lock()
  - The Lock object can be hold by only one thread at a time.If any other thread requires the same lock then it has to wait until thread releases lock.
  - Thread can acquire the lock by using acquire() 
  - Thread can release the lock by using release()
  - The standard Lock object does not care which thread is currently holding the lock. If the lock is held and any thread attempts to acquire lock, then it will be blocked, even the same thread is holding the lock.

- RLock
  - Re-entrant Lock
  - Reentrant means the thread can acquire the same lock again and again. If the lock is held by other threads then only the thread will be blocked.
  - Reentrant facility is available only for owner thread but not for other threads.

- Semaphore
  - In the case of Lock and RLock, at a time only one thread is allowed to execute.
  - Sometimes our requirement is at a time a particular number of threads are allowed to
access (like at a time 10 memebers are allowed to access database server, 4 members are allowed to access Network connection etc).
  - Semaphore can be used to limit the access to the shared resources with limited capacity.
  - We can create Semaphore object as follows:
    - s = Semaphore(counter) -- The default value of counter is 1.
  - Whenever thread executes acquire() method,then the counter value will be decremented by 1 and if thread executes release() method then the counter value will be incremented by 1.
  - BounedSemaphore is exactly same as Semaphore except that the number of release() calls should not exceed the number of acquire() calls,otherwise we will get ValueError: Semaphore released too many times

#### Inter-thread Communication
- Event
  - Event object is the simplest communication mechanism between the threads. One thread signals an event and other threads wait for it.
  - Event manages an internal flag that can set() or clear()

- Condition
  - Condition is the more advanced version of Event object for interthread communication.
  - A condition represents some kind of state change in the application like producing item or consuming item. Threads can wait for that condition and threads can be notified once condition occurs .i.e Condition object allows one or more threads to wait until notified by another thread.
  - Condition is always associated with a lock (ReentrantLock).
  - A condition has acquire() and release() methods that call the corresponding methods of the associated lock.

- Queue
  - Queue is the most enhanced mechanism for inter-thread communication and to share data between threads.
  - Queue internally uses Condition and Condition uses Lock.
  - Python Supports 3 Types of Queues:
    - FIFO Queue: This is Default Behaviour. q = queue.Queue()
    - LIFO Queue: q = queue.LifoQueue()
    - Priority Queue: q=queue.PriorityQueue(). If the data is non-numeric, we have to provide our data in the form of tuple - (x,y) - x is priority, y is element
